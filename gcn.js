var fs = require('fs'),
    readline = require('readline'),
    google = require('googleapis'),
    googleAuth = require('google-auth-library'),
    open = require('open'),
    colors = require('colors');


var SCOPES = ['https://www.googleapis.com/auth/calendar.readonly'],
    TOKEN_DIR = (process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE) + '/.credentials/',
    TOKEN_PATH = TOKEN_DIR + 'calendar-nodejs-quickstart.json';


/// OAuth2 file reader
/// In order to create your own OAuth app token, go to: 
/// https://developers.google.com/google-apps/calendar/quickstart/nodejs#step_1_turn_on_the_api_name
fs.readFile('client_secret.json', function processClientSecrets(err, content) {
    if (err) {
        console.log('File "client_secret.json" not found: '.red + err);
        return;
    }
    
    authorize(JSON.parse(content), listEvents);
});

/**
 * Opens Google's Oath2 permission wizard 
 *
 * @param {Object} credentials Client credentials
 * @param {function} callback  Client callbak
 */
function authorize(credentials, callback) {
    var clientSecret = credentials.installed.client_secret,
        clientId = credentials.installed.client_id,
        redirectUrl = credentials.installed.redirect_uris[0],
        auth = new googleAuth(),
        oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
    
    // Check if we have a saved token, if not, tries to get one
    fs.readFile(TOKEN_PATH, function (err, token) {
        if (err) {
            getNewToken(oauth2Client, callback);
        } else {
            oauth2Client.credentials = JSON.parse(token);
            callback(oauth2Client);
        }
    });
}

/**
 * Gathers a new token for this app
 *
 * @param {google.auth.OAuth2} oauth2Client OAuth2 client
 * @param {getEventsCallback} callback Authorization callback
 */
function getNewToken(oauth2Client, callback) {
    
    var authUrl = oauth2Client.generateAuthUrl({ access_type: 'offline', scope: SCOPES });
    
    console.log();
    console.log('In order to continue please follow the link that was opened in your default browser'.yellow);
    open(authUrl);
    var rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    console.log();
    rl.question('Type the code generated by Google in the previous step: '.cyan, function (code) {
        rl.close();
        oauth2Client.getToken(code, function (err, token) {
            if (err) {
                console.log('It was not possible to validate your token!'.red, err);
                return;
            }
            oauth2Client.credentials = token;
            storeToken(token);
            callback(oauth2Client);
        });
    });
}

/**
 * Saves the token data for future use
 *
 * @param {Object} token Token for the client
 */
function storeToken(token) {
    
    try {
        fs.mkdirSync(TOKEN_DIR);
    } catch (err) {
        if (err.code != 'EEXIST') {
            throw err;
        }
    }
    fs.writeFile(TOKEN_PATH, JSON.stringify(token));
    console.log('Token stored to ' + TOKEN_PATH);
}


/**
 * Gathers all future events from user's calendar
 *
 * @param {calendarAPI} calendarAPI Calendar API Instance.
 * @param {google.auth.OAuth2} auth Cliente OAuth.
 * @param {calendar} item Google calendar data.
 */
function getEvents(calendarAPI, auth, item) {

    calendarAPI.events.list({
        auth: auth,
        calendarId: item.id,
		maxResults: 2500,
        singleEvents: true,
        orderBy: 'startTime'
    }, function (err, response) {
	
        if (err) {
            console.log('API (events) error: '.red + err);
            return;
        }
        var events = response.items;
        if ((!response.items) || (events.length == 0)) {
            
            console.log('No event found.'.yellow);
        } else {
            
            console.log(events.length + ' events found.'.green);
            
            var data = "";
            for (var i = 0; i < events.length; i++) {
                
                var event = events[i];
                var start = event.start.dateTime || event.start.date;
                console.log('%s - %s', start, event.summary);
                var description = typeof event.description !== 'undefined' ? event.description.replace(/\r?\n|\r/g, "").replace(/\;/g, "|") : "";
                data += item.summary + ";" +
                        event.summary + ";" +
                        description + ";" +   
                        start + ";" +
                        (event.end.dateTime || event.end.date) + ";" +
                        event.location + ";" +
                        event.organizer.email + ";" +
                        "\n";
            }
            
            fs.writeFile('events' + item.summary + '.csv', data, 'utf8', function (err) {
                if (err) { return console.log(err); }
                console.log('Done [' +item.summary + ']!'.green);
            });
        }
    });
}

/**
 * Gathers all future events from ALL user's calendars
 *
 * @param {google.auth.OAuth2} auth Cliente OAuth.
 */
function listEvents(auth) {
    var calendarAPI = google.calendar('v3');
    
    var lists = calendarAPI.calendarList.list({ auth: auth }, 
	function (err, calendars) {
		if (err) {
            console.log('API (calendars) error: '.red + err);
            return;
        }
		
        for (var c = 0; c < calendars.items.length; c++) {
                getEvents(calendarAPI, auth, calendars.items[c]);
		}
    });
	
}
